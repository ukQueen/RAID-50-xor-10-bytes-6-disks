\documentclass[10pt,a4paper,final]{article} %draft

\usepackage[english, russian]{babel}

\usepackage{geometry}
%\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm,bindingo ffset=0cm]{geometry}

\usepackage[utf8]{inputenc}

\usepackage[final]{pdfpages}

\usepackage{textcomp,enumitem}

\usepackage{amsmath,amsthm,amssymb}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codegreen}{rgb}{0,0.5,0} % зеленый цвет
\definecolor{codeblue}{rgb}{0,0,0.5} % синий цвет
\definecolor{codestring}{rgb}{0.64,0.08,0.08} % цвет строк


\lstset{
	language=C++,
	extendedchars=true,
	literate=
	{а}{{\selectfont\char224}}1
	{б}{{\selectfont\char225}}1
	{в}{{\selectfont\char226}}1
	{г}{{\selectfont\char227}}1
	{д}{{\selectfont\char228}}1
	{е}{{\selectfont\char229}}1
	{ж}{{\selectfont\char230}}1
	{з}{{\selectfont\char231}}1
	{и}{{\selectfont\char232}}1
	{й}{{\selectfont\char233}}1
	{к}{{\selectfont\char234}}1
	{л}{{\selectfont\char235}}1
	{м}{{\selectfont\char236}}1
	{н}{{\selectfont\char237}}1
	{о}{{\selectfont\char238}}1
	{п}{{\selectfont\char239}}1
	{р}{{\selectfont\char240}}1
	{с}{{\selectfont\char241}}1
	{т}{{\selectfont\char242}}1
	{у}{{\selectfont\char243}}1
	{ф}{{\selectfont\char244}}1
	{х}{{\selectfont\char245}}1
	{ц}{{\selectfont\char246}}1
	{ч}{{\selectfont\char247}}1
	{ш}{{\selectfont\char248}}1
	{щ}{{\selectfont\char249}}1
	{ъ}{{\selectfont\char250}}1
	{ы}{{\selectfont\char251}}1
	{ь}{{\selectfont\char252}}1
	{э}{{\selectfont\char253}}1
	{ю}{{\selectfont\char254}}1
	{я}{{\selectfont\char255}}1
	{А}{{\selectfont\char192}}1
	{Б}{{\selectfont\char193}}1
	{В}{{\selectfont\char194}}1
	{Г}{{\selectfont\char195}}1
	{Д}{{\selectfont\char196}}1
	{Е}{{\selectfont\char197}}1
	{Ж}{{\selectfont\char198}}1
	{З}{{\selectfont\char199}}1
	{И}{{\selectfont\char200}}1
	{Й}{{\selectfont\char201}}1
	{К}{{\selectfont\char202}}1
	{Л}{{\selectfont\char203}}1
	{М}{{\selectfont\char204}}1
	{Н}{{\selectfont\char205}}1
	{О}{{\selectfont\char206}}1
	{П}{{\selectfont\char207}}1
	{Р}{{\selectfont\char208}}1
	{С}{{\selectfont\char209}}1
	{Т}{{\selectfont\char210}}1
	{У}{{\selectfont\char211}}1
	{Ф}{{\selectfont\char212}}1
	{Х}{{\selectfont\char213}}1
	{Ц}{{\selectfont\char214}}1
	{Ч}{{\selectfont\char215}}1
	{Ш}{{\selectfont\char216}}1
	{Щ}{{\selectfont\char217}}1
	{Ъ}{{\selectfont\char218}}1
	{Ы}{{\selectfont\char219}}1
	{Ь}{{\selectfont\char220}}1
	{Э}{{\selectfont\char221}}1
	{Ю}{{\selectfont\char222}}1
	{Я}{{\selectfont\char223}}1,
	%	{|}{{\textbar}}1,
	%	{||}{{\textbar\textbar}}1
	%	{\&}{{\string&}}1
	%	{==}{{\string==}}1
	%	{\string\\}{{\string\\}}1,
	numbers=left,
	stepnumber=1,
	firstnumber=1,
	numberstyle=\tiny,
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	frame=single,
	keywordstyle=\color{codeblue}, % ключевые слова
	commentstyle=\color{codegreen}, % комментарии
	stringstyle=\color{codestring}, % строки
	%identifierstyle=\color{green}, % стиль для переменных
	backgroundcolor=\color{codegray},
}
%\usepackage{fancyvrb}

%\usepackage{fancyhdr}

%\usepackage{upgreek}

%\usepackage{tipa}

%\usepackage{tikz}

%\usepackage{graphicx}

%\usepackage{pgfplots}

\usepackage{indentfirst}

%\usepackage{gensymb}

%\usepackage{amssymb}

%\usepackage{pdfpages}

\usepackage[unicode, pdftex, colorlinks, urlcolor=blue]{hyperref}

%\usepackage[T2A]{fontenc}


\usepackage{tabularx}
\usepackage{multirow}


\usepackage{graphics}

\linespread{1.5}

\pagestyle{plain}

%\usepackage{listings} 
%\usepackage{moreverb} 

%\setlist[enumerate,itemize]{leftmargin=1.2cm} %отступ в перечислениях

\hypersetup{
	colorlinks=true,
	linkcolor=black,
	%allcolors=[RGB]{0 0 0}}
	}
	%\lstloadlanguages{ [LaTeX] TeX}
	
	\lstloadlanguages{ [LaTeX] TeX}
	
	
	
	\textheight=24cm 
	\textwidth=16cm
	\oddsidemargin=0pt 
	\topmargin=-1.5cm
	\parindent=24pt 
	\parskip=0pt 
	\tolerance=2000 
	\flushbottom 
	
	%\usepackage[font=scriptsize]{caption}
	\usepackage[labelsep=period]{caption}
	
	\begin{document}
\thispagestyle{empty}

\begin{center}
	{\Large МИНОБРНАУКИ РОССИИ}\\
	~\\
	{\large ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ПРОФЕССИОНАЛЬНОГО ОБРАЗОВАНИЯ}\\
	~\\
	{\Large \bf <<САНКТ-ПЕТЕРБУРГСКИЙ ПОЛИТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ ПЕТРА ВЕЛИКОГО>>}\\
	~\\
	{\large Институт компьютерных наук и кибербезопасности}\\
	{\large Высшая школа технологий искусственного интеллекта}\\
	{\large Направление 02.03.01 Математика и компьютерные науки}\\
	~\\
	~\\
	~\\
	~\\
	{\Large \bf Отчет о выполнении работы}\\
	{\Large по дисциплине <<Архитектура суперкомпьютеров>> }\\
	~\\
	~\\
	
	{\Large Разработка приложения, демонстрирующего работу RAID-массива 50 из 6 дисков и заданным размером исходного сообщения -- 10 байт.}\\
	%	{\Large \bf }\\ 	
	~\\
	~\\
	~\\
	~\\
	~\\
	~\\
	~\\
	{\large Обучающийся: \underline{\hspace{3.5cm}} \qquad\qquad Гладков И.А.}\\
	~\\
	{\large Руководитель: \underline{\hspace{3.5cm}} \hspace{14mm} Чуватов М.В.}\\
	~\\
	~\\
\end{center}
\begin{flushright}
	
	«\underline{\hspace{1cm}}»\underline{\hspace{3cm}}20\underline{\hspace{0.7cm}}г.
\end{flushright}
~\\
\begin{center}
	{\large Санкт-Петербург, 2024}
\end{center}
\newpage

\tableofcontents

\newpage
\section* {Введение}
\addcontentsline{toc}{section}{Введение}

Цель работы: реализовать программу, демонстрирующую работу RAID-массива из 6 дисков и 10 байтовым размером исходного сообщения.

\textbf{Условие работы:}

\begin{enumerate}
	\item Подсчет избыточности  происходит с помощью  операции XOR;
	\item Размер входных данных -- 10 байт;
	\item Количество дисков в массиве - 6 единиц;
	\item Количество адрессов в массиве -- 64 единицы.
\end{enumerate}

\textbf{Задачи:}
\begin{enumerate}
	\item Изучить строение дискового массива RAID 50;
	\item Изучить организацию записи подсчета избыточности;
	\item Реализовать модель, демонстрирующую работу избыточного массива независимых дисков RAID 50;
	\item Протестировать полученную модель.
\end{enumerate}

\textbf{Условия работы модели:}
\begin{enumerate}
	\item Модель записывать данные по определенному адресу;
	\item Модель предоставлять пользователю возможность прочесть данные по определенному адресу;
	\item Модель должна восстановить один из дисков, если тот выйдет из строя.
\end{enumerate}


\newpage
\section{Математическое описание}
\subsection{RAID-массив}

RAID (Redundant Array of Independent Disks) - это технология, которая используется для объединения нескольких физических дисков в единое логическое устройство с целью повышения производительности, надежности или обоих параметров. Основная идея RAID заключается в том, чтобы скомбинировать несколько дисков таким образом, чтобы данные сохранялись и обрабатывались в более эффективном и надежном формате, чем при использовании отдельных дисков.

Избыточные данные в контексте RAID-массивов относятся к дополнительной информации, которая создается и сохраняется для обеспечения отказоустойчивости и восстановления данных в случае сбоя одного или нескольких дисков. Избыточность позволяет системам продолжать работу и восстанавливать потерянные данные без серьезных потерь или простоев. 

\subsubsection{Классификация RAID-массивов}

RAID-массивы классифицируются по уровню избыточности данных и способу организации дисков. Основные уровни RAID и их характеристики:

{\large \textbf{RAID 0:}}
\begin{itemize}
	\item \textbf{Техника хранения данных:} Данные разбиваются на небольшие блоки и записываются на различные диски параллельно, что называется стримингом. Каждый блок данных хранится на отдельном диске.
	\item \textbf{Производительность:} RAID 0 обеспечивает высокую скорость чтения и записи данных за счет распределения данных между дисками. Однако производительность может снизиться при отказе одного из дисков.
	\item \textbf{Избыточность данных:} RAID 0 не предоставляет избыточности данных. Если один из дисков выходит из строя, весь массив становится недоступным, и данные на нем теряются.
	\item \textbf{Применение:} Часто используется в ситуациях, где важна высокая производительность, а сохранность данных не является критической, например, для временных хранилищ или кэширования.
\end{itemize}

{\large \textbf{RAID 1:}}
\begin{itemize}
	\item \textbf{Техника хранения данных:} RAID 1 использует зеркалирование данных. Каждый блок данных записывается на два или более диска, обеспечивая полную копию данных на каждом диске.
	\item \textbf{Производительность:} Чтение данных может быть немного быстрее, так как можно использовать любой из зеркальных дисков. Однако производительность записи обычно ниже, чем у RAID 0.
	\item \textbf{Избыточность данных:} RAID 1 предоставляет полную избыточность данных. Если один из дисков выходит из строя, данные могут быть восстановлены с зеркального диска.
	\item \textbf{Применение:} Используется в приложениях, где важна надежность хранения данных, таких как системы резервного копирования или серверы баз данных.
\end{itemize}

{\large \textbf{RAID 5:}}
\begin{itemize}
	\item \textbf{Техника хранения данных:} RAID 5 использует распределенное хранение четности. Данные разбиваются на блоки, а блоки четности распределяются между дисками.
	\item \textbf{Производительность:} RAID 5 обеспечивает хорошую производительность чтения и некоторое увеличение производительности записи. Он обычно эффективен для случайного доступа к данным.
	\item \textbf{Избыточность данных:} RAID 5 предоставляет избыточность данных. При отказе одного из дисков данные могут быть восстановлены из блоков четности и данных на оставшихся дисках.
	\item \textbf{Применение:} Часто используется в корпоративных серверах, где важны и надежность хранения данных, и производительность.
\end{itemize}

{\large \textbf{RAID 6:}}
\begin{itemize}
	\item \textbf{Техника хранения данных:} RAID 6 аналогичен RAID 5, но использует два блока четности для обеспечения избыточности данных.
	\item \textbf{Производительность:} RAID 6 обеспечивает производительность чтения и записи данных, сравнимую с RAID 5. Однако производительность записи может быть немного медленнее из-за расчетов двух блоков четности.
	\item \textbf{Избыточность данных:} RAID 6 предоставляет двойную избыточность данных. Он может выдержать отказ до двух дисков без потери данных.
	\item \textbf{Применение:} Используется в критически важных средах, где требуется высокий уровень надежности, например, в больших хранилищах данных или при хранении ценной корпоративной информации.
\end{itemize}


\newpage
\subsection{Комбинированные уровни RAID-массивов}

{\large \textbf{RAID 50:}}
\begin{enumerate}
	\item \textbf{Исходные диски:} Массив RAID 50 начинается с минимум шести физических дисков, объединяемых в два или более наборов RAID 5.
	
	\item \textbf{Создание наборов RAID 5:} Каждый набор RAID 5 содержит минимум три диска и обеспечивает избыточность данных с использованием распределенной четности.
	
	\item \textbf{Объединение наборов RAID 5 в RAID 0:} Наборы RAID 5 объединяются в массив RAID 0 путем стриминга данных, что обеспечивает высокую производительность записи и чтения.
	
	\item \textbf{Преимущества:}
	\begin{itemize}
		\item RAID 50 обеспечивает высокую производительность и избыточность данных, объединяя преимущества RAID 0 и RAID 5.
		\item Он предоставляет высокую производительность благодаря RAID 0 и защиту данных благодаря RAID 5.
	\end{itemize}
	
	\item \textbf{Недостатки:}
	\begin{itemize}
		\item Создание массива RAID 50 требует минимум шести дисков, что может быть дорого и сложно для некоторых систем.
		\item Обновление или замена дисков в массиве RAID 50 может быть сложным из-за его сложной структуры.
	\end{itemize}
	
	\item \textbf{Применение:} RAID 50 идеально подходит для сред и приложений, где требуется высокая производительность и избыточность данных, например, для серверов баз данных, виртуализации серверов и видеопотоков.
\end{enumerate}

\newpage
\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{1}
\caption{RAID 50}
\end{figure}
На рисунке 1 представлена схема RAID 50 для 6 дисков. Данные распределяются на четыре части, оставшиеся две части отведены на избыточность. Рассмотрим первую строчку данных: данные разделяются на четыре блока -- А1, А2, А3, А4. Данные блоки разделяются на определенное количество частей, в данном случае, на две. Для первой из них находится блок избыточности с помощью операции XOR -- $A_p$. Данные из первой части записываются на диски, также записывается избыточнось. Аналогично записывается вторая часть данных. 


\newpage
\section{Особенности реализации}

В качестве дисков приложение использует текстовые файлы (один диск -- один файлы, один блок сообщения -- одна строка файла). Программа сама обеспечивает присутствие файлов дисков в правильном формате, пересчитывая поврежденные или удаленные файлы дисков, если это возможно,иначе она заново инициализирует все файлы дисков. Каждый диск может хранить до 64 строк данных.

Размещение блоков внутри строки для 6 дисков выглядит следующим образом:

\begin{table}[h!]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		\textbf{Disk 0} & \textbf{Disk 1} & \textbf{Disk 2} & \textbf{Disk 3} & \textbf{Disk 4} & \textbf{Disk 5} \\
		\hline
		$A_{P1}$ & $A_1$ & $A_2$ & $A_{P2}$ & $A_3$ & $A_4$ \\
		\hline
		$B_1$ & $B_{P1}$ & $B_2$ & $B_3$ & $B_{P2}$ & $B_4$ \\
		\hline
		$C_1$ & $C_2$ & $C_{P1}$ & $C_3$ & $C_4$ & $C_{P2}$ \\
		\hline
		$D_{P1}$ & $D_1$ & $D_2$ & $D_{P2}$ & $D_3$ & $D_4$ \\
		\hline
	\end{tabular}
\end{table}

Сообщение подается в виде 10-байтовой строки. $A_i$ является байтом данного сообщения. Например передается сообщение $12345678$, представим по блокам: $A_1$ = 123, $A_2$ = 45, $A_3$ = 678, $A_4$ = 90. После сообщение делится на две части $A_1$ - $A_2$ и $A_3$ - $A_4$.Каждый блок дополняется до 3 байт незначащими нулями. После для каждой из частей находится блок избыточности по байтово (например для $A_1$ и $A_2$ получается $A_P1$). После все записывается на диски как показано в таблице.

\subsection{Реализованные функции}

\textbf{{\large Функция xor}}

Возвращает результат побитового XOR двух строк.

\begin{lstlisting}
	def xor(a: str, b: str) -> str:
		return ''.join([chr(ord(x) ^ ord(y)) for x, y in zip(a, b)])
	
\end{lstlisting}

\textbf{{\large Функция recovery}}

Восстанавливает данные на одном из дисков, используя оставшиеся данные и избыточные данные с других дисков группы RAID 5. Проверяет, какой RAID (RAID\_5\_1 или RAID\_5\_2) имеет проблему, считывает данные с остальных дисков и восстанавливает утраченные данные.
\begin{lstlisting}
	def recovery(disks_index: int) -> None:
	global index_of_disk
	global RAID_5_1
	global RAID_5_2
	
	if disks_index < 3:
	problem_raid = RAID_5_1
	problem_index = disks_index
	else:
	problem_raid = RAID_5_2
	problem_index = disks_index - 3
	
	lost_data = []
	data = []
	for i in range(len(problem_raid)):
	if i != problem_index:
	with open(problem_raid[i], 'r') as file:
	data.append([x for x in file.readlines() if x != '_\n'])
	else:
	data.append(["*" * 3] * 64)
	
	if data[0][0] != "***":
	cond = data[0]
	else:
	cond = data[1]
	for i in range(len(cond)):
	disk_data = []
	for j in range(len(data)):
	disk_data.append(data[j][i][:3])
	
	indexes = [ind for ind in range(len(disk_data)) if disk_data[ind] != "***"]
	
	if len(indexes) == 2:
	a = disk_data[indexes[0]]
	b = disk_data[indexes[1]]
	buf = xor(disk_data[indexes[0]], disk_data[indexes[1]])
	lost_data.append(buf)
	
	ind = 0
	with open(disks[disks_index], 'w') as file:
	for i in range(64):
	if i in index_of_disk:
	file.write(lost_data[ind] + '\n')
	ind += 1
	else:
	file.write("_\n")
	
	print("Диск {} был восстановлен.".format(disks_index))
\end{lstlisting}

\textbf{{\large Функция check\_disks}}

Проверяет, какие диски отсутствуют. Если отсутствует более одного диска в одной группе RAID, данные восстановить невозможно. В случае, если данные могут быть восстановлены, вызывает функцию \textbf{recovery} для отсутствующих дисков.
\begin{lstlisting}
	def check_disks():
	disk_indexes = []
	can_recovery = True
	for i in range(len(disks)):
	if not os.path.isfile(disks[i]):
	disk_indexes.append(i)
	
	if len(disk_indexes) == 2:
	if not ((0 <= disk_indexes[0] <= 2 and 3 <= disk_indexes[1] <= 5) or
	(0 <= disk_indexes[1] <= 2 and 3 <= disk_indexes[0] <= 5)):
	can_recovery = False
	elif len(disk_indexes) > 2:
	can_recovery = False
	
	if can_recovery:
	for disk in disk_indexes:
	print("\nДиск {} отсутствовал.".format(disk))
	recovery(disk)
	else:
	output = "\nДиски "
	for i in range(len(disk_indexes)):
	output += str(disk_indexes[i])
	if i < len(disk_indexes) - 1:
	output += ', '
	
	output += " отсутсвуют"
	print(output)
	print("\nДиски с данными невозможно востановить")
	return "Данные невозможно востановить"
\end{lstlisting}

\textbf{{\large Функция read}}

Читает данные из строки с указанным индексом. Проверяет наличие дисков и их целостность. Восстанавливает данные, если необходимо, и выводит содержимое строки.
\begin{lstlisting}
	def read() -> None:
	global index_of_disk
	if len(index_of_disk) == 0:
	print('\nДиски пусты.\n')
	return
	
	if check_disks() != "Данные невозможно востановить":
	while True:
	index = input("\nВведите индекс строки которую хотите прочитать [0;63]: ")
	if int(index) > 63 or int(index) < 0:
	print("индекс вне диапазона [0;63].")
	elif int(index) not in index_of_disk:
	print("Данных нет по данному адресу.")
	else:
	break
	
	data = []
	
	for i in range(len(disks)):
	file = open(disks[i], 'r')
	data += [file.readlines()]
	file.close()
	
	result = ''
	index = int(index)
	for i in range(len(data)):
	if int(index % 3) != int(i % 3):
	if len(data[i][int(index)][:-1]) == 3:
	buf = str(data[i][int(index)][:-1])
	
	if ''.join(chr(0)) in buf:
	buf = buf.replace(''.join(chr(0)), '')
	result += buf
	else:
	if i < len(data)//2:
	indexes = [ind for ind in range(len(data)//2) if ind != int(index % 3) and ind != i]
	recover_string = data[int(index % 3)][index]
	else:
	indexes = [ind for ind in range(len(data)//2, len(data)) if ind != int(index % 3) + 3 and ind != i]
	recover_string = data[int(index % 3) + 3][index]
	result += xor(data[indexes[0]], recover_string)
	
	print("Данные по адресу {}: ".format(index))
	print(f"{result}\n")
\end{lstlisting}

\textbf{{\large Функция write}}

Записывает данные в строку с указанным индексом. Разбивает введенные данные на блоки, вычисляет избыточные данные и записывает их на соответствующие диски. Обновляет \textbf{index\_of\_disk} для отслеживания изменений.
\begin{lstlisting}
	def write() -> None:
	if check_disks() != "Данные невозможно востановить":
	global index_of_disk
	
	while True:
	index = int(input("\nВведите индекс строки для записи в диапазоне[0;63]: "))
	if  int(index) > 63 or int(index) < 0:
	print("введенный индекс вне диапазона [0;63].")
	else:
	break
	
	while True:
	input_data = str(input("Введите строку (10 байт): "))
	if len(input_data) != 10:
	print("Длина строки должна состоять из 10 байт.")
	else:
	break
	
	blocks = [input_data[:3], input_data[3:5], input_data[5:8], input_data[8:10]]
	for i in range(len(blocks)):
	while (len(blocks[i]) < 3):
	blocks[i] = ''.join(chr(0)) + blocks[i]
	
	# Обновляем данные для первой и второй группы
	excess_data1 = xor(blocks[0], blocks[1])
	excess_data2 = xor(blocks[2], blocks[3])
	
	index_of_disk.append(index)
	index_of_disk = list(set(index_of_disk))
	l1 = ['', '', '']
	l2 = ['', '', '']
	
	l1[index % 3] = excess_data1
	l2[index % 3] = excess_data2
	indexes = [x for x in range(len(l1)) if x != index % 3]
	
	l1[indexes[0]] = blocks[0]
	l1[indexes[1]] = blocks[1]
	
	l2[indexes[0]] = blocks[2]
	l2[indexes[1]] = blocks[3]
	
	result_data = []
	for x in disks:
	file = open(x, "r")
	result_data.append(file.readlines())
	file.close()
	
	for i in range(len(RAID_5_1)):
	result_data[i][index] = l1[i] + '\n'
	result_data[i+3][index] = l2[i] + '\n'
	
	for i in range(len(disks)):
	file = open(disks[i], "w")
	for j in range(len(result_data[0])):
	file.write(result_data[i][j])
	file.close()
	
	print('Данные записаны в строку под индексом {}.\n'.format(index))
\end{lstlisting}

\textbf{{\large Функция files}}

Инициализирует файлы дисков, если они не существуют, или очищает их, если уже существуют. Записывает 64 строки со знаком "\_" в каждый файл.
\begin{lstlisting}
	def files() -> None:
	global disks
	for x in disks:
	if not os.path.exists(x):
	with open(x, "w") as file:
	for i in range(64):
	file.write("_\n")
	else:
	with open(x, "r") as file:
	lines = file.readlines()
	if len(lines) == 0:
	with open(x, "w") as file_append:
	for i in range(64):
	file_append.write("_\n")
	else:
	with open(x, "w") as file:
	for i in range(64):
	file.write("_\n")
\end{lstlisting}

\subsection{Пример записи и чтения данных}
В начале всегда прописывается индекс строки, с которой необходимо работать, после пишется либо команда \textbf{write} либо команда \textbf{read}. После команды \textbf{write} необходимо написать строку в шестнадцатеричной системе счисления, состоящую из 12 байт.

Пример:
\begin{lstlisting}
----- Меню действий -----
[1] - Записать данные.
[2] - Прочитать данные.
[0] - Выход.
-------------------------
Выберите действие: 
Такой команды нет.
----- Меню действий -----
[1] - Записать данные.
[2] - Прочитать данные.
[0] - Выход.
-------------------------
Выберите действие: 1

Введите индекс строки для записи в диапазоне[0;63]: 0
Введите строку (10 байт): 1234567890
Данные записаны в строку под индексом 0.

----- Меню действий -----
[1] - Записать данные.
[2] - Прочитать данные.
[0] - Выход.
-------------------------
Выберите действие: 2

Введите индекс строки которую хотите прочитать [0;63]: 0
Данные по адресу 0: 
1234567890

\end{lstlisting}

\newpage
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

В результате работы была реализована модель, демонстрирующая работу избыточного массива независимых дисков RAID 50 на основе 6 дисков для ввода 10-байтовой строки с подсчетом избыточности через операцию XOR. Полученная модель позволяет записывать, читать данные и восстанавливать один из дисков в случае его выхода из строя.

Исходя из поставленных целей и задач, были выполнены следующие этапы:
\begin{enumerate}
	\item был произведен анализ источников информации, содержащие сведения об избыточного массива независимых дисков. Этот анализ позволил понять основные принципы работы RAID 50.
	\item Была реализована модель, демонстрирующая работу избыточного массива независимых дисков RAID 50 на основе 6 дисков для ввода 10-байтовой строки с подсчетом избыточности через операцию XOR. Полученная модель позволяет записывать, читать данные и восстанавливать один из дисков в случае его выхода из строя.
	\item  Произведено тестирование реализованной модели, что позволило убедиться в корректности реализации программы.
\end{enumerate}


\newpage
\section* {Источники}
\addcontentsline{toc}{section}{Источники}
\begin{quote}
	1. RAID 50 (RAID 5+0) [электронный ресурс] URL:\\ \href{https://www.techtarget.com/searchstorage/definition/RAID-50-RAID-50}{https://www.techtarget.com/searchstorage/definition/RAID-50-RAID-50}\\
	(Дата обращения 24.05.2024)\\
	2. RAID — Википедия [электронный ресурс] URL:\\
	\href{https://ru.wikipedia.org/wiki/RAID}{https://ru.wikipedia.org/wiki/RAID} \\
	(Дата обращения 24.05.2024)\\
	3. RAID Calculator [электронный ресурс] URL:\\ \href{https://www.raid-calculator.com/default.aspx}{https://www.raid-calculator.com/default.aspx} \\
	(Дата обращения 24.05.2024)\\
\end{quote}






\end{document}